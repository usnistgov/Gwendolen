/*
*	New C++ File starts here.
*	This file should be named sensor_datan_c_n.c
*/

/* Include all C language NML and CMS function prototypes. */
#include "nmlcms_c.h"

/* Include externally supplied prototypes. */
#include "sensor_datan_c_n.h"

/* Forward Function Prototypes */
#ifdef __cplusplus
extern "C" {
#endif

void cms_sense_data_update(struct cms_c_struct *cms, nml_sense_data_c_t *x);
void cms_SENSOR_DATA_MSG_update(struct cms_c_struct *cms, nml_SENSOR_DATA_MSG_c_t *x);

#ifdef __cplusplus
}
#endif
long nml_sensor_data_open(const char *buf, const char *proc, const char *cfg)
{
	return (long) nml_new(sensor_data_c_format, buf,proc,cfg);
}

int  nml_sensor_data_valid(long nml_id)
{
	return (int) nml_valid( (nml_c_t) nml_id);
}

void nml_sensor_data_close(long nml_id)
{
	nml_free( (nml_c_t) nml_id);
}

int nml_sensor_data_read(long nml_id)
{
	return (long) nml_read( (nml_c_t) nml_id);
}

int nml_sensor_data_SENSOR_DATA_MSG_write(long nml_id, const nml_SENSOR_DATA_MSG_c_t *msg){
	return (int) nml_write( (nml_c_t) nml_id,(void *) msg, (nmltype_c_t) 115000,sizeof(nml_SENSOR_DATA_MSG_c_t));
}

nml_SENSOR_DATA_MSG_c_t * nml_sensor_data_SENSOR_DATA_MSG_get_msg(long nml_id){
	return (nml_SENSOR_DATA_MSG_c_t *) nml_get_address( (nml_c_t) nml_id);
}




#ifndef MAX_SENSOR_DATA_C_NAME_LENGTH
#define MAX_SENSOR_DATA_C_NAME_LENGTH 16
#endif
#ifndef SENSOR_DATA_C_NAME_LIST_LENGTH
#define SENSOR_DATA_C_NAME_LIST_LENGTH 2
#endif


/* This list must be in alphabetical order and the three lists must correspond. */
const char sensor_data_c_name_list[SENSOR_DATA_C_NAME_LIST_LENGTH][MAX_SENSOR_DATA_C_NAME_LENGTH]= {
	"SENSOR_DATA_MSG", /* 0,115000 */
	""};
const NMLTYPE sensor_data_c_id_list[SENSOR_DATA_C_NAME_LIST_LENGTH]= {
	SENSOR_DATA_MSG_TYPE, /* 0,115000 */
	-1};
const size_t sensor_data_c_size_list[SENSOR_DATA_C_NAME_LIST_LENGTH]= {
	sizeof(nml_SENSOR_DATA_MSG_c_t),
	0};
const char *sensor_data_c_symbol_lookup(long type);


/* Enumerated Type Constants */

/*
*	NML/CMS Format function : sensor_data_c_format
*	Automatically generated by NML CodeGen Java Applet.
*	on Sat Feb 25 10:10:20 EST 2006
*/
int sensor_data_c_format(long type, void *buffer, struct cms_c_struct *cms)
{

	type = cms_check_type_info(cms,type,buffer,"sensor_data_c",
		(cms_symbol_lookup_function_t) sensor_data_c_symbol_lookup,
		(const char **)sensor_data_c_name_list,
		sensor_data_c_id_list,sensor_data_c_size_list,
		SENSOR_DATA_C_NAME_LIST_LENGTH,
		MAX_SENSOR_DATA_C_NAME_LENGTH);

	switch(type)
	{
	case SENSOR_DATA_MSG_TYPE:
		cms_SENSOR_DATA_MSG_update(cms,(nml_SENSOR_DATA_MSG_c_t *) buffer);
		break;

	default:
		return(0);
	}
	return 1;
}


/* NML Symbol Lookup Function */
const char *sensor_data_c_symbol_lookup(long type)
{
	switch(type)
	{
	case SENSOR_DATA_MSG_TYPE:
		return "SENSOR_DATA_MSG";
	default:
		return"UNKNOWN";
		break;
	}
	return(NULL);
}

/*
*	NML/CMS Update function for sense_data
*	Automatically generated by NML CodeGen Java Applet.
*	on Sat Feb 25 10:10:20 EST 2006
*/
void cms_sense_data_update(struct cms_c_struct *cms, nml_sense_data_c_t *x)
{

	cms_begin_class(cms,"sense_data",0);
	cms_update_float(cms,"range",&(x->range));
	cms_update_float(cms,"intensity",&(x->intensity));

	cms_end_class(cms,"sense_data",0);

}


/*
*	NML/CMS Update function for SENSOR_DATA_MSG
*	Automatically generated by NML CodeGen Java Applet.
*	on Sat Feb 25 10:10:20 EST 2006
*/
void cms_SENSOR_DATA_MSG_update(struct cms_c_struct *cms, nml_SENSOR_DATA_MSG_c_t *x)
{

	cms_begin_class(cms,"SENSOR_DATA_MSG","NMLmsg");
	cms_update_int(cms,"sd_length",&(x->sd_length));
	cms_begin_struct_dynamic_array(cms,"sd",&(x->sd_length), 5000);

	{
		int i_sd=0;

			for(i_sd = 0;i_sd < x->sd_length; i_sd++)
		{
			cms_begin_struct_array_elem(cms,"sd",i_sd);
			cms_sense_data_update(cms,&(( x->sd)[i_sd]));
			cms_end_struct_array_elem(cms,"sd",i_sd);
		}
	}

	cms_end_struct_dynamic_array(cms,"sd",&(x->sd_length), 5000);

	cms_end_class(cms,"SENSOR_DATA_MSG","NMLmsg");

}

