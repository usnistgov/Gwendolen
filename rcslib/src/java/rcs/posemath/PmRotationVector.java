/* 
 The NIST RCS (Real-time Control Systems) 
 library is public domain software, however it is preferred
 that the following disclaimers be attached.

 Software Copywrite/Warranty Disclaimer

 This software was developed at the National Institute of Standards and
 Technology by employees of the Federal Government in the course of their
 official duties. Pursuant to title 17 Section 105 of the United States
 Code this software is not subject to copyright protection and is in the
 public domain. NIST Real-Time Control System software is an experimental
 system. NIST assumes no responsibility whatsoever for its use by other
 parties, and makes no guarantees, expressed or implied, about its
 quality, reliability, or any other characteristic. We would appreciate
 acknowledgement if the software is used. This software can be
 redistributed and/or modified freely provided that any derivative works
 bear some notice that they are derived from it, and any modified
 versions bear some notice that they have been modified.



 */

/*
 *       New Java File starts here.
 *       This file should be named PmRotationVector.java
 */
// Set Package Name
package rcs.posemath;

// Import all NML, CMS, and RCS classes and interfaces
import java.util.logging.Level;
import java.util.logging.Logger;
import rcs.nml.NMLFormatConverter;

/*
 *       Class definition for PmRotationVector
 *       Automatically generated by RCS Java Diagnostics Tool.
 *       on Wed Jan 07 10:53:44 EST 1998
 */
public class PmRotationVector implements Cloneable {

    public double s = 0;
    public double x = 0;
    public double y = 0;
    public double z = 0;

    public void update(NMLFormatConverter nml_fc) {
        nml_fc.beginClass("PmRotationVector", null);
        s = nml_fc.update_with_name("s", s);
        x = nml_fc.update_with_name("x", x);
        y = nml_fc.update_with_name("y", y);
        z = nml_fc.update_with_name("z", z);
        nml_fc.endClass("PmRotationVector", null);
    }

    public PmRotationVector() {
    }

    public PmRotationVector(double starts, double startx, double starty, double startz) throws PmException {
        s = starts;
        x = startx;
        y = starty;
        z = startz;
        Posemath.pmRotNorm(this, this);
    }
    
    public PmRotationVector(PmRotationVector rv) throws PmException {
        this(rv.s, rv.x, rv.y, rv.z);
    }

    public PmRotationVector(PmRotationMatrix rm) throws PmException {
        this(Posemath.toRot(rm));
    }

    public PmRotationVector(PmRpy rpy) throws PmException {
        this(Posemath.toRot(rpy));
    }
    
    public PmRotationVector(PmQuaternion quat) throws PmException {
        this(Posemath.toRot(quat));
    }

    
    public PmRotationVector multiply(PmRotationMatrix other) throws PmException {
        PmRotationVector ret = new PmRotationVector();
        PmQuaternion qthis = Posemath.toQuat(this);
        PmQuaternion qother = Posemath.toQuat(other);
        PM_QUATERNION qret = new PM_QUATERNION();
        Posemath.pmQuatQuatMult(qthis, qother, qret);
        Posemath.pmQuatRotConvert(qret,ret);
        return ret;
    }
    
    public PmRotationVector multiply(PmRpy other) throws PmException {
        PmRotationVector ret = new PmRotationVector();
        PmQuaternion qthis = Posemath.toQuat(this);
        PmQuaternion qother = Posemath.toQuat(other);
        PM_QUATERNION qret = new PM_QUATERNION();
        Posemath.pmQuatQuatMult(qthis, qother, qret);
        Posemath.pmQuatRotConvert(qret,ret);
        return ret;
    }
    
    public PmRotationVector multiply(PmQuaternion qother) throws PmException {
        PmRotationVector ret = new PmRotationVector();
        PmQuaternion qthis = Posemath.toQuat(this);
        PM_QUATERNION qret = new PM_QUATERNION();
        Posemath.pmQuatQuatMult(qthis, qother, qret);
        Posemath.pmQuatRotConvert(qret,ret);
        return ret;
    }
    
    public PmRotationVector multiply(double s) {
        PmRotationVector out = this.clone();
        out.s *= s;
        return out;
    }

    public PmRotationVector multiply(PmRotationVector other) throws PmException {
        PmRotationMatrix mthis = new PmRotationMatrix();
        Posemath.pmRotMatConvert(this, mthis);
        PmRotationMatrix mother = new PmRotationMatrix();
        Posemath.pmRotMatConvert(other, mother);
        PmRotationMatrix mout = new PmRotationMatrix();
        Posemath.pmMatMatMult(mthis, mother, mout);
        PmRotationVector v = new PmRotationVector();
        Posemath.pmMatRotConvert(mout, v);
        return v;
    }

    public PmRotationVector inv() throws PmException {
        PmRotationVector ri = new PmRotationVector();
        PmRotationMatrix m = new PmRotationMatrix();
        Posemath.pmRotMatConvert(this, m);
        m = m.inv();
        Posemath.pmMatRotConvert(m, ri);
        return ri;
    }

    @Override
    public PmRotationVector clone() {
        PmRotationVector cloned_object = null;
        try {
            cloned_object = (PmRotationVector) super.clone();
            cloned_object.s = this.s;
            cloned_object.x = this.x;
            cloned_object.y = this.y;
            cloned_object.z = this.z;
        } catch (CloneNotSupportedException ex) {
            Logger.getLogger(PmRotationVector.class.getName()).log(Level.SEVERE, null, ex);
        }
        return cloned_object;
    }

}
